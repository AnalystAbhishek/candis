#!/usr/bin/python

# imports - compatibility imports
from __future__ import print_function

# imports - standard imports
import sys, os, os.path as osp
import subprocess
import logging
from distutils.spawn import find_executable

logging.basicConfig()
log = logging.getLogger('get-candis')
log.setLevel(logging.DEBUG)

class const(object):
    URL_HOMEBREW_INSTALL       = 'https://raw.githubusercontent.com/Homebrew/install/master/install'
    HOMEBREW_DEPENDENCIES      = ['git', 'python3', 'gcc', 'r', 'graphviz']
    HOMEBREW_DEPENDENCIES_CASK = ['xquartz', 'weka']
    URL_CANDIS                 = 'https://github.com/HelikarLab/candis'

def which(executable, raise_err = False):
    path = find_executable(executable)

    if not path and raise_err:
        raise ValueError('{executable} not found.'.format(executable = executable))
    
    return path

def popen(*params, **kwargs):
    output      = kwargs.get('output', True)
    directory   = kwargs.get('dir')
    environment = kwargs.get('env')
    raise_err   = kwargs.get('raise_err', True)

    environ     = os.environ.copy()
    if environment:
        environ.update(environment)
    
    proc        = subprocess.Popen(params,
        # stdin   = subprocess.PIPE,
        # stdout  = subprocess.PIPE,
        # stderr  = subprocess.PIPE,
        env     = environ,
        cwd     = directory
    )

    # if output:
    #     for line in iter(proc.stdout.readline, ""):
    #         print(line, end = '')
    code       = proc.wait()
    if code:
        if raise_err:
            raise subprocess.CalledProcessError(code, params)

    out, err   = proc.communicate()

    return code

def check_git_dir(dirpath, raise_err = True):
    git     = which('git', raise_err = True)
    
    if osp.isdir(dirpath) \
        and osp.isdir(osp.join(dirpath, '.git')) \
        and not popen(git, 'rev-parse', '--is-inside-work-tree', dir = dirpath, raise_err = False):
        
        return True
    else:
        if raise_err:
            raise ValueError('{path} not a valid git repository.'.format(
                path = dirpath
            ))
        else:
            return False

def setup_candis():
    appdir  = osp.join(osp.expanduser('~'), 'candis')
    
    if not osp.exists(appdir):
        git = which('git', raise_err = True)
        popen(git, 'clone', '--recursive', const.URL_CANDIS, appdir)
    else:
        check_git_dir(appdir)

    Rscript = which('Rscript', raise_err = True)
    popen(Rscript, 'setup.R', dir = osp.join(appdir, 'R'))

    python3 = which('python3', raise_err = True)
    pip3    = which('pip3', raise_err = True)
    popen(pip3, 'install', 'virtualenv')

    venv    = which('virtualenv', raise_err = True)
    popen(venv, '--python', python3, osp.join(appdir, '.venv'))
    venv    = osp.join(appdir, '.venv')

    # python3 = osp.join(venv, 'bin', 'python')
    # pip3    = osp.join(venv, 'bin', 'pip')

    popen(pip3, 'install', 'numpy')
    popen(pip3, 'install', '-r', osp.join(appdir, 'requirements.txt'))

    with open(osp.join(osp.expanduser('~'), '.matplotlib', 'matplotlibrc'), mode = 'a') as f:
        f.write('\nbackend: TkAgg')
        
def main(args = None):
    code    = os.EX_OK

    brew    = which('brew')
    if not brew:
        curl    = which('curl', raise_err = True)
        ruby    = which('ruby', raise_err = True)
        
        pout    = popen(curl, const.URL_HOMEBREW_INSTALL, output = False)
        popen(ruby, '-e', pout)

    brew    = which('brew', raise_err = True)
    popen(brew, 'update')

    popen(brew, 'tap',  'homebrew/science')
    popen(brew, 'tap',  'caskroom/cask')

    popen(brew, 'cask', 'install', *const.HOMEBREW_DEPENDENCIES_CASK, raise_err = False)
    popen(brew,         'install', *const.HOMEBREW_DEPENDENCIES, raise_err = False)
    
    setup_candis()

    return code

if __name__ == '__main__':
    args = sys.argv[1:]
    code = main(args)

    sys.exit(code)